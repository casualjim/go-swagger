// Code generated by go-swagger; DO NOT EDIT.

package cli

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"
	"fmt"

	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-swagger/go-swagger/fixtures/bugs/2969/codegen/models"
	"github.com/spf13/cobra"
)

// Schema cli for TaskExecutionStatusV21

// register flags to command
func registerModelTaskExecutionStatusV21Flags(depth int, cmdPrefix string, cmd *cobra.Command) error {

	if err := registerTaskExecutionStatusV21PropErrorMessage(depth, cmdPrefix, cmd); err != nil {
		return err
	}

	if err := registerTaskExecutionStatusV21PropExecutionID(depth, cmdPrefix, cmd); err != nil {
		return err
	}

	if err := registerTaskExecutionStatusV21PropExecutionStatus(depth, cmdPrefix, cmd); err != nil {
		return err
	}

	if err := registerTaskExecutionStatusV21PropExecutionType(depth, cmdPrefix, cmd); err != nil {
		return err
	}

	if err := registerTaskExecutionStatusV21PropFinishTimestamp(depth, cmdPrefix, cmd); err != nil {
		return err
	}

	if err := registerTaskExecutionStatusV21PropRuntime(depth, cmdPrefix, cmd); err != nil {
		return err
	}

	if err := registerTaskExecutionStatusV21PropStartTimestamp(depth, cmdPrefix, cmd); err != nil {
		return err
	}

	if err := registerTaskExecutionStatusV21PropStatus(depth, cmdPrefix, cmd); err != nil {
		return err
	}

	if err := registerTaskExecutionStatusV21PropTaskID(depth, cmdPrefix, cmd); err != nil {
		return err
	}

	if err := registerTaskExecutionStatusV21PropTaskVersion(depth, cmdPrefix, cmd); err != nil {
		return err
	}

	if err := registerTaskExecutionStatusV21PropTimeout(depth, cmdPrefix, cmd); err != nil {
		return err
	}

	if err := registerTaskExecutionStatusV21PropTriggerTimestamp(depth, cmdPrefix, cmd); err != nil {
		return err
	}

	if err := registerTaskExecutionStatusV21PropUserID(depth, cmdPrefix, cmd); err != nil {
		return err
	}

	if err := registerTaskExecutionStatusV21PropUserType(depth, cmdPrefix, cmd); err != nil {
		return err
	}

	return nil
}

func registerTaskExecutionStatusV21PropErrorMessage(depth int, cmdPrefix string, cmd *cobra.Command) error {
	if depth > maxDepth {
		return nil
	}

	errorMessageDescription := `Error message if error occurs`

	var errorMessageFlagName string
	if cmdPrefix == "" {
		errorMessageFlagName = "errorMessage"
	} else {
		errorMessageFlagName = fmt.Sprintf("%v.errorMessage", cmdPrefix)
	}

	var errorMessageFlagDefault string

	_ = cmd.PersistentFlags().String(errorMessageFlagName, errorMessageFlagDefault, errorMessageDescription)

	return nil
}

func registerTaskExecutionStatusV21PropExecutionID(depth int, cmdPrefix string, cmd *cobra.Command) error {
	if depth > maxDepth {
		return nil
	}

	executionIdDescription := `Required. Job execution ID`

	var executionIdFlagName string
	if cmdPrefix == "" {
		executionIdFlagName = "executionId"
	} else {
		executionIdFlagName = fmt.Sprintf("%v.executionId", cmdPrefix)
	}

	var executionIdFlagDefault string

	_ = cmd.PersistentFlags().String(executionIdFlagName, executionIdFlagDefault, executionIdDescription)

	return nil
}

func registerTaskExecutionStatusV21PropExecutionStatus(depth int, cmdPrefix string, cmd *cobra.Command) error {
	if depth > maxDepth {
		return nil
	}

	executionStatusDescription := `Enum: ["DEPLOY_FAILED","EXECUTION_SUCCESS","EXECUTION_FAILED","EXECUTION_TERMINATED","EXECUTION_TERMINATED_TIMEOUT","EXECUTION_REJECTED","EXECUTION_EVENT_RECEIVED","DISPATCHING_FLOW","STARTING_FLOW_EXECUTION","STOPPING_FLOW_EXECUTION","UNKNOWN"]. Required. Execution (detailed) status`

	var executionStatusFlagName string
	if cmdPrefix == "" {
		executionStatusFlagName = "executionStatus"
	} else {
		executionStatusFlagName = fmt.Sprintf("%v.executionStatus", cmdPrefix)
	}

	var executionStatusFlagDefault string

	_ = cmd.PersistentFlags().String(executionStatusFlagName, executionStatusFlagDefault, executionStatusDescription)

	if err := cmd.RegisterFlagCompletionFunc(executionStatusFlagName,
		func(cmd *cobra.Command, args []string, toComplete string) ([]string, cobra.ShellCompDirective) {
			var res []string
			if err := json.Unmarshal([]byte(`["DEPLOY_FAILED","EXECUTION_SUCCESS","EXECUTION_FAILED","EXECUTION_TERMINATED","EXECUTION_TERMINATED_TIMEOUT","EXECUTION_REJECTED","EXECUTION_EVENT_RECEIVED","DISPATCHING_FLOW","STARTING_FLOW_EXECUTION","STOPPING_FLOW_EXECUTION","UNKNOWN"]`), &res); err != nil {
				panic(err)
			}
			return res, cobra.ShellCompDirectiveDefault
		}); err != nil {
		return err
	}

	return nil
}

func registerTaskExecutionStatusV21PropExecutionType(depth int, cmdPrefix string, cmd *cobra.Command) error {
	if depth > maxDepth {
		return nil
	}

	executionTypeDescription := `Enum: ["MANUAL","SCHEDULED","WEBHOOK","PLAN"]. Required. Execution type`

	var executionTypeFlagName string
	if cmdPrefix == "" {
		executionTypeFlagName = "executionType"
	} else {
		executionTypeFlagName = fmt.Sprintf("%v.executionType", cmdPrefix)
	}

	var executionTypeFlagDefault string

	_ = cmd.PersistentFlags().String(executionTypeFlagName, executionTypeFlagDefault, executionTypeDescription)

	if err := cmd.RegisterFlagCompletionFunc(executionTypeFlagName,
		func(cmd *cobra.Command, args []string, toComplete string) ([]string, cobra.ShellCompDirective) {
			var res []string
			if err := json.Unmarshal([]byte(`["MANUAL","SCHEDULED","WEBHOOK","PLAN"]`), &res); err != nil {
				panic(err)
			}
			return res, cobra.ShellCompDirectiveDefault
		}); err != nil {
		return err
	}

	return nil
}

func registerTaskExecutionStatusV21PropFinishTimestamp(depth int, cmdPrefix string, cmd *cobra.Command) error {
	if depth > maxDepth {
		return nil
	}

	finishTimestampDescription := `End time of job execution`

	var finishTimestampFlagName string
	if cmdPrefix == "" {
		finishTimestampFlagName = "finishTimestamp"
	} else {
		finishTimestampFlagName = fmt.Sprintf("%v.finishTimestamp", cmdPrefix)
	}

	_ = cmd.PersistentFlags().String(finishTimestampFlagName, "", finishTimestampDescription)

	return nil
}

func registerTaskExecutionStatusV21PropRuntime(depth int, cmdPrefix string, cmd *cobra.Command) error {
	if depth > maxDepth {
		return nil
	}

	var runtimeFlagName string
	if cmdPrefix == "" {
		runtimeFlagName = "runtime"
	} else {
		runtimeFlagName = fmt.Sprintf("%v.runtime", cmdPrefix)
	}

	if err := registerModelRuntimeFlags(depth+1, runtimeFlagName, cmd); err != nil {
		return err
	}

	return nil
}

func registerTaskExecutionStatusV21PropStartTimestamp(depth int, cmdPrefix string, cmd *cobra.Command) error {
	if depth > maxDepth {
		return nil
	}

	startTimestampDescription := `Required. Start time of job execution`

	var startTimestampFlagName string
	if cmdPrefix == "" {
		startTimestampFlagName = "startTimestamp"
	} else {
		startTimestampFlagName = fmt.Sprintf("%v.startTimestamp", cmdPrefix)
	}

	_ = cmd.PersistentFlags().String(startTimestampFlagName, "", startTimestampDescription)

	return nil
}

func registerTaskExecutionStatusV21PropStatus(depth int, cmdPrefix string, cmd *cobra.Command) error {
	if depth > maxDepth {
		return nil
	}

	statusDescription := `Enum: ["dispatching","deploy_failed","executing","execution_successful","execution_rejected","execution_failed","terminated","terminated_timeout"]. Required. Execution status`

	var statusFlagName string
	if cmdPrefix == "" {
		statusFlagName = "status"
	} else {
		statusFlagName = fmt.Sprintf("%v.status", cmdPrefix)
	}

	var statusFlagDefault string

	_ = cmd.PersistentFlags().String(statusFlagName, statusFlagDefault, statusDescription)

	if err := cmd.RegisterFlagCompletionFunc(statusFlagName,
		func(cmd *cobra.Command, args []string, toComplete string) ([]string, cobra.ShellCompDirective) {
			var res []string
			if err := json.Unmarshal([]byte(`["dispatching","deploy_failed","executing","execution_successful","execution_rejected","execution_failed","terminated","terminated_timeout"]`), &res); err != nil {
				panic(err)
			}
			return res, cobra.ShellCompDirectiveDefault
		}); err != nil {
		return err
	}

	return nil
}

func registerTaskExecutionStatusV21PropTaskID(depth int, cmdPrefix string, cmd *cobra.Command) error {
	if depth > maxDepth {
		return nil
	}

	taskIdDescription := `Required. Task Id`

	var taskIdFlagName string
	if cmdPrefix == "" {
		taskIdFlagName = "taskId"
	} else {
		taskIdFlagName = fmt.Sprintf("%v.taskId", cmdPrefix)
	}

	var taskIdFlagDefault string

	_ = cmd.PersistentFlags().String(taskIdFlagName, taskIdFlagDefault, taskIdDescription)

	return nil
}

func registerTaskExecutionStatusV21PropTaskVersion(depth int, cmdPrefix string, cmd *cobra.Command) error {
	if depth > maxDepth {
		return nil
	}

	taskVersionDescription := `Required. Task version`

	var taskVersionFlagName string
	if cmdPrefix == "" {
		taskVersionFlagName = "taskVersion"
	} else {
		taskVersionFlagName = fmt.Sprintf("%v.taskVersion", cmdPrefix)
	}

	var taskVersionFlagDefault string

	_ = cmd.PersistentFlags().String(taskVersionFlagName, taskVersionFlagDefault, taskVersionDescription)

	return nil
}

func registerTaskExecutionStatusV21PropTimeout(depth int, cmdPrefix string, cmd *cobra.Command) error {
	if depth > maxDepth {
		return nil
	}

	timeoutDescription := `Execution timeout if set (in minutes)`

	var timeoutFlagName string
	if cmdPrefix == "" {
		timeoutFlagName = "timeout"
	} else {
		timeoutFlagName = fmt.Sprintf("%v.timeout", cmdPrefix)
	}

	var timeoutFlagDefault int32

	_ = cmd.PersistentFlags().Int32(timeoutFlagName, timeoutFlagDefault, timeoutDescription)

	return nil
}

func registerTaskExecutionStatusV21PropTriggerTimestamp(depth int, cmdPrefix string, cmd *cobra.Command) error {
	if depth > maxDepth {
		return nil
	}

	triggerTimestampDescription := `Required. Trigger time of job execution`

	var triggerTimestampFlagName string
	if cmdPrefix == "" {
		triggerTimestampFlagName = "triggerTimestamp"
	} else {
		triggerTimestampFlagName = fmt.Sprintf("%v.triggerTimestamp", cmdPrefix)
	}

	_ = cmd.PersistentFlags().String(triggerTimestampFlagName, "", triggerTimestampDescription)

	return nil
}

func registerTaskExecutionStatusV21PropUserID(depth int, cmdPrefix string, cmd *cobra.Command) error {
	if depth > maxDepth {
		return nil
	}

	userIdDescription := `Required. User who triggered or scheduled the execution`

	var userIdFlagName string
	if cmdPrefix == "" {
		userIdFlagName = "userId"
	} else {
		userIdFlagName = fmt.Sprintf("%v.userId", cmdPrefix)
	}

	var userIdFlagDefault string

	_ = cmd.PersistentFlags().String(userIdFlagName, userIdFlagDefault, userIdDescription)

	return nil
}

func registerTaskExecutionStatusV21PropUserType(depth int, cmdPrefix string, cmd *cobra.Command) error {
	if depth > maxDepth {
		return nil
	}

	userTypeDescription := `Enum: ["HUMAN","SERVICE"]. Required. Type of user who triggered or scheduled the execution`

	var userTypeFlagName string
	if cmdPrefix == "" {
		userTypeFlagName = "userType"
	} else {
		userTypeFlagName = fmt.Sprintf("%v.userType", cmdPrefix)
	}

	var userTypeFlagDefault string

	_ = cmd.PersistentFlags().String(userTypeFlagName, userTypeFlagDefault, userTypeDescription)

	if err := cmd.RegisterFlagCompletionFunc(userTypeFlagName,
		func(cmd *cobra.Command, args []string, toComplete string) ([]string, cobra.ShellCompDirective) {
			var res []string
			if err := json.Unmarshal([]byte(`["HUMAN","SERVICE"]`), &res); err != nil {
				panic(err)
			}
			return res, cobra.ShellCompDirectiveDefault
		}); err != nil {
		return err
	}

	return nil
}

// retrieve flags from commands, and set value in model. Return true if any flag is passed by user to fill model field.
func retrieveModelTaskExecutionStatusV21Flags(depth int, m *models.TaskExecutionStatusV21, cmdPrefix string, cmd *cobra.Command) (error, bool) {
	retAdded := false

	err, errorMessageAdded := retrieveTaskExecutionStatusV21PropErrorMessageFlags(depth, m, cmdPrefix, cmd)
	if err != nil {
		return err, false
	}
	retAdded = retAdded || errorMessageAdded

	err, executionIdAdded := retrieveTaskExecutionStatusV21PropExecutionIDFlags(depth, m, cmdPrefix, cmd)
	if err != nil {
		return err, false
	}
	retAdded = retAdded || executionIdAdded

	err, executionStatusAdded := retrieveTaskExecutionStatusV21PropExecutionStatusFlags(depth, m, cmdPrefix, cmd)
	if err != nil {
		return err, false
	}
	retAdded = retAdded || executionStatusAdded

	err, executionTypeAdded := retrieveTaskExecutionStatusV21PropExecutionTypeFlags(depth, m, cmdPrefix, cmd)
	if err != nil {
		return err, false
	}
	retAdded = retAdded || executionTypeAdded

	err, finishTimestampAdded := retrieveTaskExecutionStatusV21PropFinishTimestampFlags(depth, m, cmdPrefix, cmd)
	if err != nil {
		return err, false
	}
	retAdded = retAdded || finishTimestampAdded

	err, runtimeAdded := retrieveTaskExecutionStatusV21PropRuntimeFlags(depth, m, cmdPrefix, cmd)
	if err != nil {
		return err, false
	}
	retAdded = retAdded || runtimeAdded

	err, startTimestampAdded := retrieveTaskExecutionStatusV21PropStartTimestampFlags(depth, m, cmdPrefix, cmd)
	if err != nil {
		return err, false
	}
	retAdded = retAdded || startTimestampAdded

	err, statusAdded := retrieveTaskExecutionStatusV21PropStatusFlags(depth, m, cmdPrefix, cmd)
	if err != nil {
		return err, false
	}
	retAdded = retAdded || statusAdded

	err, taskIdAdded := retrieveTaskExecutionStatusV21PropTaskIDFlags(depth, m, cmdPrefix, cmd)
	if err != nil {
		return err, false
	}
	retAdded = retAdded || taskIdAdded

	err, taskVersionAdded := retrieveTaskExecutionStatusV21PropTaskVersionFlags(depth, m, cmdPrefix, cmd)
	if err != nil {
		return err, false
	}
	retAdded = retAdded || taskVersionAdded

	err, timeoutAdded := retrieveTaskExecutionStatusV21PropTimeoutFlags(depth, m, cmdPrefix, cmd)
	if err != nil {
		return err, false
	}
	retAdded = retAdded || timeoutAdded

	err, triggerTimestampAdded := retrieveTaskExecutionStatusV21PropTriggerTimestampFlags(depth, m, cmdPrefix, cmd)
	if err != nil {
		return err, false
	}
	retAdded = retAdded || triggerTimestampAdded

	err, userIdAdded := retrieveTaskExecutionStatusV21PropUserIDFlags(depth, m, cmdPrefix, cmd)
	if err != nil {
		return err, false
	}
	retAdded = retAdded || userIdAdded

	err, userTypeAdded := retrieveTaskExecutionStatusV21PropUserTypeFlags(depth, m, cmdPrefix, cmd)
	if err != nil {
		return err, false
	}
	retAdded = retAdded || userTypeAdded

	return nil, retAdded
}

func retrieveTaskExecutionStatusV21PropErrorMessageFlags(depth int, m *models.TaskExecutionStatusV21, cmdPrefix string, cmd *cobra.Command) (error, bool) {
	if depth > maxDepth {
		return nil, false
	}
	retAdded := false

	errorMessageFlagName := fmt.Sprintf("%v.errorMessage", cmdPrefix)
	if cmd.Flags().Changed(errorMessageFlagName) {

		var errorMessageFlagName string
		if cmdPrefix == "" {
			errorMessageFlagName = "errorMessage"
		} else {
			errorMessageFlagName = fmt.Sprintf("%v.errorMessage", cmdPrefix)
		}

		errorMessageFlagValue, err := cmd.Flags().GetString(errorMessageFlagName)
		if err != nil {
			return err, false
		}
		m.ErrorMessage = errorMessageFlagValue

		retAdded = true
	}

	return nil, retAdded
}

func retrieveTaskExecutionStatusV21PropExecutionIDFlags(depth int, m *models.TaskExecutionStatusV21, cmdPrefix string, cmd *cobra.Command) (error, bool) {
	if depth > maxDepth {
		return nil, false
	}
	retAdded := false

	executionIdFlagName := fmt.Sprintf("%v.executionId", cmdPrefix)
	if cmd.Flags().Changed(executionIdFlagName) {

		var executionIdFlagName string
		if cmdPrefix == "" {
			executionIdFlagName = "executionId"
		} else {
			executionIdFlagName = fmt.Sprintf("%v.executionId", cmdPrefix)
		}

		executionIdFlagValue, err := cmd.Flags().GetString(executionIdFlagName)
		if err != nil {
			return err, false
		}
		m.ExecutionID = &executionIdFlagValue

		retAdded = true
	}

	return nil, retAdded
}

func retrieveTaskExecutionStatusV21PropExecutionStatusFlags(depth int, m *models.TaskExecutionStatusV21, cmdPrefix string, cmd *cobra.Command) (error, bool) {
	if depth > maxDepth {
		return nil, false
	}
	retAdded := false

	executionStatusFlagName := fmt.Sprintf("%v.executionStatus", cmdPrefix)
	if cmd.Flags().Changed(executionStatusFlagName) {

		var executionStatusFlagName string
		if cmdPrefix == "" {
			executionStatusFlagName = "executionStatus"
		} else {
			executionStatusFlagName = fmt.Sprintf("%v.executionStatus", cmdPrefix)
		}

		executionStatusFlagValue, err := cmd.Flags().GetString(executionStatusFlagName)
		if err != nil {
			return err, false
		}
		m.ExecutionStatus = &executionStatusFlagValue

		retAdded = true
	}

	return nil, retAdded
}

func retrieveTaskExecutionStatusV21PropExecutionTypeFlags(depth int, m *models.TaskExecutionStatusV21, cmdPrefix string, cmd *cobra.Command) (error, bool) {
	if depth > maxDepth {
		return nil, false
	}
	retAdded := false

	executionTypeFlagName := fmt.Sprintf("%v.executionType", cmdPrefix)
	if cmd.Flags().Changed(executionTypeFlagName) {

		var executionTypeFlagName string
		if cmdPrefix == "" {
			executionTypeFlagName = "executionType"
		} else {
			executionTypeFlagName = fmt.Sprintf("%v.executionType", cmdPrefix)
		}

		executionTypeFlagValue, err := cmd.Flags().GetString(executionTypeFlagName)
		if err != nil {
			return err, false
		}
		m.ExecutionType = &executionTypeFlagValue

		retAdded = true
	}

	return nil, retAdded
}

func retrieveTaskExecutionStatusV21PropFinishTimestampFlags(depth int, m *models.TaskExecutionStatusV21, cmdPrefix string, cmd *cobra.Command) (error, bool) {
	if depth > maxDepth {
		return nil, false
	}
	retAdded := false

	finishTimestampFlagName := fmt.Sprintf("%v.finishTimestamp", cmdPrefix)
	if cmd.Flags().Changed(finishTimestampFlagName) {

		var finishTimestampFlagName string
		if cmdPrefix == "" {
			finishTimestampFlagName = "finishTimestamp"
		} else {
			finishTimestampFlagName = fmt.Sprintf("%v.finishTimestamp", cmdPrefix)
		}

		finishTimestampFlagValueStr, err := cmd.Flags().GetString(finishTimestampFlagName)
		if err != nil {
			return err, false
		}
		var finishTimestampFlagValue strfmt.DateTime
		if err := finishTimestampFlagValue.UnmarshalText([]byte(finishTimestampFlagValueStr)); err != nil {
			return err, false
		}
		m.FinishTimestamp = finishTimestampFlagValue

		retAdded = true
	}

	return nil, retAdded
}

func retrieveTaskExecutionStatusV21PropRuntimeFlags(depth int, m *models.TaskExecutionStatusV21, cmdPrefix string, cmd *cobra.Command) (error, bool) {
	if depth > maxDepth {
		return nil, false
	}
	retAdded := false

	runtimeFlagName := fmt.Sprintf("%v.runtime", cmdPrefix)
	if cmd.Flags().Changed(runtimeFlagName) {
		// info: complex object runtime Runtime is retrieved outside this Changed() block
	}
	runtimeFlagValue := m.Runtime
	if swag.IsZero(runtimeFlagValue) {
		runtimeFlagValue = &models.Runtime{}
	}

	err, runtimeAdded := retrieveModelRuntimeFlags(depth+1, runtimeFlagValue, runtimeFlagName, cmd)
	if err != nil {
		return err, false
	}
	retAdded = retAdded || runtimeAdded
	if runtimeAdded {
		m.Runtime = runtimeFlagValue
	}

	return nil, retAdded
}

func retrieveTaskExecutionStatusV21PropStartTimestampFlags(depth int, m *models.TaskExecutionStatusV21, cmdPrefix string, cmd *cobra.Command) (error, bool) {
	if depth > maxDepth {
		return nil, false
	}
	retAdded := false

	startTimestampFlagName := fmt.Sprintf("%v.startTimestamp", cmdPrefix)
	if cmd.Flags().Changed(startTimestampFlagName) {

		var startTimestampFlagName string
		if cmdPrefix == "" {
			startTimestampFlagName = "startTimestamp"
		} else {
			startTimestampFlagName = fmt.Sprintf("%v.startTimestamp", cmdPrefix)
		}

		startTimestampFlagValueStr, err := cmd.Flags().GetString(startTimestampFlagName)
		if err != nil {
			return err, false
		}
		var startTimestampFlagValue strfmt.DateTime
		if err := startTimestampFlagValue.UnmarshalText([]byte(startTimestampFlagValueStr)); err != nil {
			return err, false
		}
		m.StartTimestamp = &startTimestampFlagValue

		retAdded = true
	}

	return nil, retAdded
}

func retrieveTaskExecutionStatusV21PropStatusFlags(depth int, m *models.TaskExecutionStatusV21, cmdPrefix string, cmd *cobra.Command) (error, bool) {
	if depth > maxDepth {
		return nil, false
	}
	retAdded := false

	statusFlagName := fmt.Sprintf("%v.status", cmdPrefix)
	if cmd.Flags().Changed(statusFlagName) {

		var statusFlagName string
		if cmdPrefix == "" {
			statusFlagName = "status"
		} else {
			statusFlagName = fmt.Sprintf("%v.status", cmdPrefix)
		}

		statusFlagValue, err := cmd.Flags().GetString(statusFlagName)
		if err != nil {
			return err, false
		}
		m.Status = &statusFlagValue

		retAdded = true
	}

	return nil, retAdded
}

func retrieveTaskExecutionStatusV21PropTaskIDFlags(depth int, m *models.TaskExecutionStatusV21, cmdPrefix string, cmd *cobra.Command) (error, bool) {
	if depth > maxDepth {
		return nil, false
	}
	retAdded := false

	taskIdFlagName := fmt.Sprintf("%v.taskId", cmdPrefix)
	if cmd.Flags().Changed(taskIdFlagName) {

		var taskIdFlagName string
		if cmdPrefix == "" {
			taskIdFlagName = "taskId"
		} else {
			taskIdFlagName = fmt.Sprintf("%v.taskId", cmdPrefix)
		}

		taskIdFlagValue, err := cmd.Flags().GetString(taskIdFlagName)
		if err != nil {
			return err, false
		}
		m.TaskID = &taskIdFlagValue

		retAdded = true
	}

	return nil, retAdded
}

func retrieveTaskExecutionStatusV21PropTaskVersionFlags(depth int, m *models.TaskExecutionStatusV21, cmdPrefix string, cmd *cobra.Command) (error, bool) {
	if depth > maxDepth {
		return nil, false
	}
	retAdded := false

	taskVersionFlagName := fmt.Sprintf("%v.taskVersion", cmdPrefix)
	if cmd.Flags().Changed(taskVersionFlagName) {

		var taskVersionFlagName string
		if cmdPrefix == "" {
			taskVersionFlagName = "taskVersion"
		} else {
			taskVersionFlagName = fmt.Sprintf("%v.taskVersion", cmdPrefix)
		}

		taskVersionFlagValue, err := cmd.Flags().GetString(taskVersionFlagName)
		if err != nil {
			return err, false
		}
		m.TaskVersion = &taskVersionFlagValue

		retAdded = true
	}

	return nil, retAdded
}

func retrieveTaskExecutionStatusV21PropTimeoutFlags(depth int, m *models.TaskExecutionStatusV21, cmdPrefix string, cmd *cobra.Command) (error, bool) {
	if depth > maxDepth {
		return nil, false
	}
	retAdded := false

	timeoutFlagName := fmt.Sprintf("%v.timeout", cmdPrefix)
	if cmd.Flags().Changed(timeoutFlagName) {

		var timeoutFlagName string
		if cmdPrefix == "" {
			timeoutFlagName = "timeout"
		} else {
			timeoutFlagName = fmt.Sprintf("%v.timeout", cmdPrefix)
		}

		timeoutFlagValue, err := cmd.Flags().GetInt32(timeoutFlagName)
		if err != nil {
			return err, false
		}
		m.Timeout = timeoutFlagValue

		retAdded = true
	}

	return nil, retAdded
}

func retrieveTaskExecutionStatusV21PropTriggerTimestampFlags(depth int, m *models.TaskExecutionStatusV21, cmdPrefix string, cmd *cobra.Command) (error, bool) {
	if depth > maxDepth {
		return nil, false
	}
	retAdded := false

	triggerTimestampFlagName := fmt.Sprintf("%v.triggerTimestamp", cmdPrefix)
	if cmd.Flags().Changed(triggerTimestampFlagName) {

		var triggerTimestampFlagName string
		if cmdPrefix == "" {
			triggerTimestampFlagName = "triggerTimestamp"
		} else {
			triggerTimestampFlagName = fmt.Sprintf("%v.triggerTimestamp", cmdPrefix)
		}

		triggerTimestampFlagValueStr, err := cmd.Flags().GetString(triggerTimestampFlagName)
		if err != nil {
			return err, false
		}
		var triggerTimestampFlagValue strfmt.DateTime
		if err := triggerTimestampFlagValue.UnmarshalText([]byte(triggerTimestampFlagValueStr)); err != nil {
			return err, false
		}
		m.TriggerTimestamp = &triggerTimestampFlagValue

		retAdded = true
	}

	return nil, retAdded
}

func retrieveTaskExecutionStatusV21PropUserIDFlags(depth int, m *models.TaskExecutionStatusV21, cmdPrefix string, cmd *cobra.Command) (error, bool) {
	if depth > maxDepth {
		return nil, false
	}
	retAdded := false

	userIdFlagName := fmt.Sprintf("%v.userId", cmdPrefix)
	if cmd.Flags().Changed(userIdFlagName) {

		var userIdFlagName string
		if cmdPrefix == "" {
			userIdFlagName = "userId"
		} else {
			userIdFlagName = fmt.Sprintf("%v.userId", cmdPrefix)
		}

		userIdFlagValue, err := cmd.Flags().GetString(userIdFlagName)
		if err != nil {
			return err, false
		}
		m.UserID = &userIdFlagValue

		retAdded = true
	}

	return nil, retAdded
}

func retrieveTaskExecutionStatusV21PropUserTypeFlags(depth int, m *models.TaskExecutionStatusV21, cmdPrefix string, cmd *cobra.Command) (error, bool) {
	if depth > maxDepth {
		return nil, false
	}
	retAdded := false

	userTypeFlagName := fmt.Sprintf("%v.userType", cmdPrefix)
	if cmd.Flags().Changed(userTypeFlagName) {

		var userTypeFlagName string
		if cmdPrefix == "" {
			userTypeFlagName = "userType"
		} else {
			userTypeFlagName = fmt.Sprintf("%v.userType", cmdPrefix)
		}

		userTypeFlagValue, err := cmd.Flags().GetString(userTypeFlagName)
		if err != nil {
			return err, false
		}
		m.UserType = &userTypeFlagValue

		retAdded = true
	}

	return nil, retAdded
}
