{{ define "sliceparamvalidator"}}
{{ if or .MinItems .MaxItems }}
{{ camelize .Name }}Size := int64(len({{ if and (not .IsArray) (not .HasDiscriminator) (not .IsInterface) (not .IsStream) .IsNullable }}*{{ end }}{{ .ValueExpression }}))
{{ end }}
{{ if .MinItems }}
if err := validate.MinItems({{ .Path }}, {{ printf "%q" .Location }}, {{ camelize .Name }}Size, {{ .MinItems }}); err != nil {
  return err
}
{{ end }}
{{ if .MaxItems }}
if err := validate.MaxItems({{ .Path }}, {{ printf "%q" .Location }}, {{ camelize .Name }}Size, {{.MaxItems}}); err != nil {
  return err
}
{{ end }}
{{ if .UniqueItems }}
if err := validate.UniqueItems({{ .Path }}, {{ printf "%q" .Location }}, {{ if and (not .IsArray) (not .HasDiscriminator) (not .IsInterface) (not .IsStream) .IsNullable }}*{{ end }}{{ .ValueExpression }}); err != nil {
  return err
}
{{ end }}
{{ if .Enum }}
if err := validate.Enum({{ .Path }}, {{ printf "%q" .Location }}, {{ if and (not .IsArray) (not .HasDiscriminator) (not .IsInterface) (not .IsStream) .IsNullable }}*{{ end }}{{ .ValueExpression }}, {{ .Enum }}); err != nil {
  return err
}
{{ end }}
{{ end }}
{{ define "propertyparamvalidator" }}
{{ if .IsPrimitive }}{{ template "validationPrimitive" . }}{{ end }}
{{ if .IsCustomFormatter }}
if err := validate.FormatOf({{.Path}}, "{{.Location}}", "{{.SwaggerFormat}}", {{.ValueExpression}}.String(), formats); err != nil {
  return err
}{{ end }}
{{ if .IsArray }}{{ template "sliceparamvalidator" . }}{{ end -}}
{{ end }}
package {{ .Package }}

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
  "os"
  "net/http"

  "golang.org/x/net/context"

  "github.com/go-openapi/runtime"
  "github.com/go-openapi/swag"
  "github.com/go-openapi/errors"
  "github.com/go-openapi/validate"
  cr "github.com/go-openapi/runtime/client"

  strfmt "github.com/go-openapi/strfmt"

  {{ range .DefaultImports }}{{ printf "%q" .}}
  {{ end }}
  {{ range $key, $value := .Imports }}{{ $key }} {{ printf "%q" $value }}
  {{ end }}
)

// New{{ pascalize .Name }}Params creates a new {{ pascalize .Name }}Params object
// with the default values initialized.
func New{{ pascalize .Name }}Params() *{{ pascalize .Name }}Params {
  {{ if .Params }}var (
  {{ range .Params }}{{ if .HasDefault }}{{ if not .IsFileParam }}{{ varname .ID}}Default = {{ if .IsPrimitive}}{{.GoType}}({{ end}}{{ printf "%#v" .Default }}{{ if .IsPrimitive }}){{ end }}
  {{ end }}{{ end }}{{end}}
  ){{ end }}
  return &{{ pascalize .Name}}Params{
  {{ range .Params }}{{ if .HasDefault }}{{ pascalize .Name}}: {{ if and (not .IsArray) (not .IsMap) (not .HasDiscriminator) (or .IsNullable  ) }}&{{ end }}{{ varname .ID }}Default,
  {{ end }}{{ end }}
    {{ camelize .TimeoutName }}: cr.DefaultTimeout,
  }
}

// New{{ pascalize .Name }}ParamsWithTimeout creates a new {{ pascalize .Name }}Params object
// with the default values initialized, and the ability to set a timeout on a request
func New{{ pascalize .Name }}ParamsWithTimeout(timeout time.Duration) *{{ pascalize .Name }}Params {
  {{ if .Params }}var (
  {{ range .Params }}{{ if .HasDefault }}{{ if not .IsFileParam }}{{ varname .ID}}Default = {{ if .IsPrimitive}}{{.GoType}}({{ end}}{{ printf "%#v" .Default }}{{ if .IsPrimitive }}){{ end }}
  {{ end }}{{ end }}{{end}}
  ){{ end }}
  return &{{ pascalize .Name}}Params{
  {{ range .Params }}{{ if .HasDefault }}{{ pascalize .ID}}: {{ if and (not .IsArray) (not .IsMap) (not .HasDiscriminator) (or .IsNullable  ) }}&{{ end }}{{ varname .ID }}Default,
  {{ end }}{{ end }}
    {{ camelize .TimeoutName }}: timeout,
  }
}

// New{{ pascalize .Name }}ParamsWithContext creates a new {{ pascalize .Name }}Params object
// with the default values initialized, and the ability to set a context for a request
func New{{ pascalize .Name }}ParamsWithContext(ctx context.Context) *{{ pascalize .Name }}Params {
  {{ if .Params }}var (
  {{ range .Params }}{{ if .HasDefault }}{{ if not .IsFileParam }}{{ camelize .Name}}Default = {{ if .IsPrimitive}}{{.GoType}}({{ end}}{{ printf "%#v" .Default }}{{ if .IsPrimitive }}){{ end }}
  {{ end }}{{ end }}{{end}}
  ){{ end }}
  return &{{ pascalize .Name}}Params{
  {{ range .Params }}{{ if .HasDefault }}{{ pascalize .Name}}: {{ if and (not .IsArray) (not .IsMap) (not .HasDiscriminator) (or .IsNullable  ) }}&{{ end }}{{ camelize .Name }}Default,
  {{ end }}{{ end }}
    Context: ctx,
  }
}

// New{{ pascalize .Name }}ParamsWithHTTPClient creates a new {{ pascalize .Name }}Params object
// with the default values initialized, and the ability to set a custom HTTPClient for a request
func New{{ pascalize .Name }}ParamsWithHTTPClient(client *http.Client) *{{ pascalize .Name }}Params {
  {{ if .Params }}var (
  {{ range .Params }}{{ if .HasDefault }}{{ if not .IsFileParam }}{{ camelize .Name}}Default = {{ if .IsPrimitive}}{{.GoType}}({{ end}}{{ printf "%#v" .Default }}{{ if .IsPrimitive }}){{ end }}
  {{ end }}{{ end }}{{end}}
  ){{ end }}
  return &{{ pascalize .Name}}Params{
  {{ range .Params }}{{ if .HasDefault }}{{ pascalize .Name}}: {{ if and (not .IsArray) (not .IsMap) (not .HasDiscriminator) (or .IsNullable  ) }}&{{ end }}{{ camelize .Name }}Default,
  {{ end }}{{ end }}HTTPClient: client,
  }
}

/*{{ pascalize .Name }}Params contains all the parameters to send to the API endpoint
for the {{ humanize .Name }} operation typically these are written to a http.Request
*/
type {{ pascalize .Name }}Params struct {

  {{ range .Params }}/*{{ pascalize .Name }}{{ if .Description }}
  {{ .Description }}{{ end }}{{ if .Required }}
  Required: true{{ end }}{{ if .Maximum }}
  Maximum: {{ if .ExclusiveMaximum }}< {{ end }}{{ .Maximum }}{{ end }}{{ if .Minimum }}
  Minimum: {{ if .ExclusiveMinimum }}> {{ end }}{{ .Minimum }}{{ end }}{{ if .MultipleOf }}
  Multiple Of: {{ .MultipleOf }}{{ end }}{{ if .MaxLength }}
  Max Length: {{ .MaxLength }}{{ end }}{{ if .MinLength }}
  Min Length: {{ .MinLength }}{{ end }}{{ if .Pattern }}
  Pattern: {{ .Pattern }}{{ end }}{{ if .MaxItems }}
  Max Items: {{ .MaxItems }}{{ end }}{{ if .MinItems }}
  Min Items: {{ .MinItems }}{{ end }}{{ if .UniqueItems }}
  Unique: true{{ end }}{{ if .Location }}
  In: {{ .Location }}{{ end }}{{ if .CollectionFormat }}
  Collection Format: {{ .CollectionFormat }}{{ end }}{{ if .HasDefault }}
  Default: {{ printf "%#v" .Default }}{{ end }}
  */
  {{ pascalize .ID }} {{ if and (not .IsArray) (not .IsMap) (not .HasDiscriminator) (not .IsInterface) (not .IsStream) (or .IsNullable  ) }}*{{ end }}{{ if not .IsFileParam }}{{ .GoType }}{{ else }}os.File{{end}}
  {{ end }}

  {{ camelize .TimeoutName }} time.Duration
  Context context.Context
  HTTPClient *http.Client
}

// With{{ pascalize .TimeoutName }} adds the timeout to the {{ humanize .Name }} params
func ({{ .ReceiverName }} *{{ pascalize .Name }}Params) With{{ pascalize .TimeoutName }}(timeout time.Duration) *{{ pascalize .Name }}Params {
  {{ .ReceiverName }}.Set{{ pascalize .TimeoutName }}(timeout)
  return {{ .ReceiverName }}
}

// Set{{ pascalize .TimeoutName }} adds the timeout to the {{ humanize .Name }} params
func ({{ .ReceiverName }} *{{ pascalize .Name }}Params) Set{{ pascalize .TimeoutName }}(timeout time.Duration) {
  {{ .ReceiverName }}.{{ camelize .TimeoutName }} = timeout
}

// WithContext adds the context to the {{ humanize .Name }} params
func ({{ .ReceiverName }} *{{ pascalize .Name }}Params) WithContext(ctx context.Context) *{{ pascalize .Name }}Params {
  {{ .ReceiverName }}.SetContext(ctx)
  return {{ .ReceiverName }}
}

// SetContext adds the context to the {{ humanize .Name }} params
func ({{ .ReceiverName }} *{{ pascalize .Name }}Params) SetContext(ctx context.Context) {
  {{ .ReceiverName }}.Context = ctx
}

// WithHTTPClient adds the HTTPClient to the {{ humanize .Name }} params
func ({{ .ReceiverName }} *{{ pascalize .Name }}Params) WithHTTPClient(client *http.Client) *{{ pascalize .Name }}Params {
  {{ .ReceiverName }}.SetHTTPClient(client)
  return {{ .ReceiverName }}
}

// SetHTTPClient adds the HTTPClient to the {{ humanize .Name }} params
func ({{ .ReceiverName }} *{{ pascalize .Name }}Params) SetHTTPClient(client *http.Client) {
  {{ .ReceiverName }}.HTTPClient = client
}

{{ range .Params }}
// With{{ pascalize .ID }} adds the {{ varname .Name  }} to the {{ humanize $.Name }} params
func ({{ $.ReceiverName }} *{{ pascalize $.Name }}Params) With{{ pascalize .ID }}({{ varname .Name  }} {{ if and (not .IsArray) (not .IsMap) (not .HasDiscriminator) (not .IsStream) (or .IsNullable  ) }}*{{ end }}{{ if not .IsFileParam }}{{ .GoType }}{{ else }}os.File{{ end }}) *{{ pascalize $.Name }}Params {
  {{ $.ReceiverName }}.Set{{ pascalize .ID }}({{ varname .Name  }})
  return {{ .ReceiverName }}
}

// Set{{ pascalize .ID }} adds the {{ camelize .Name  }} to the {{ humanize $.Name }} params
func ({{ $.ReceiverName }} *{{ pascalize $.Name }}Params) Set{{ pascalize .ID }}({{ varname .Name  }} {{ if and (not .IsArray) (not .IsMap) (not .HasDiscriminator) (not .IsStream) (or .IsNullable  ) }}*{{ end }}{{ if not .IsFileParam }}{{ .GoType }}{{ else }}os.File{{ end }}) {
  {{ $.ReceiverName }}.{{ pascalize .ID }} = {{ varname .Name  }}
}

{{ if or .HasValidations .HasSliceValidations }}
// Validate the {{ humanize .Name }} param
func ({{ $.ReceiverName }} *{{ pascalize $.Name }}Params) validate{{ pascalize .ID }}(formats strfmt.Registry) error {
  {{ template "propertyparamvalidator" . }}
  return nil
}
{{ end }}
{{ end }}
// Validate these params
func ({{ $.ReceiverName }} *{{ pascalize $.Name }}Params) Validate(formats strfmt.Registry) error {
  {{range .Params}}{{ if or .HasValidations .HasSliceValidations }}if err := {{ $.ReceiverName }}.validate{{ pascalize .ID }}(formats); err != nil {
    return err
  }{{ else if .IsBodyParam }}{{ if .Schema.IsComplexObject }}
  {{ if .Schema.IsNullable }}if {{ $.ReceiverName }}.{{ pascalize .ID }} != nil { {{end}}
    if err := {{ $.ReceiverName }}.{{ pascalize .ID }}.Validate(formats); err != nil {
        return err
    }
  {{ if .Schema.IsNullable }} } {{end}}
  {{ end }}{{ end }}
  {{ end }}
  return nil
}

// WriteToRequest writes these params to a swagger request
func ({{ .ReceiverName }} *{{ pascalize .Name }}Params) WriteToRequest(r runtime.ClientRequest, reg strfmt.Registry) error {

  r.SetTimeout({{ .ReceiverName }}.{{ camelize .TimeoutName }})
  var res []error
  {{range .Params}}

  {{if not (or .IsArray .IsMap .IsBodyParam) }}
  {{ if and .IsNullable (not .AllowEmptyValue) }}if {{ .ValueExpression }} != nil { {{ end}}
  {{ if .IsQueryParam }}
  // query param {{ .Name }}
  {{ if .IsNullable }}var qr{{ pascalize .Name }} {{ .GoType }}
  if {{ .ValueExpression }} != nil {
    qr{{ pascalize .Name }} = *{{ .ValueExpression }}
  }{{ else }}qr{{ pascalize .Name }} := {{ .ValueExpression }}{{ end}}
  q{{ pascalize .Name}} := {{ if .Formatter }}{{ .Formatter }}(qr{{ pascalize .Name }}){{ else }}qr{{ pascalize .Name }}{{ if .IsCustomFormatter }}.String(){{end}}{{end}}{{ if not .AllowEmptyValue }}
  if q{{ pascalize .Name }} != "" { {{ end }}
  if err := r.SetQueryParam({{ printf "%q" .Name }}, q{{ pascalize .Name }}); err != nil {
    return err
  }
  {{ if not .AllowEmptyValue }}}{{ end }}
  {{ else if .IsPathParam }}
  // path param {{ .Name }}
  if err := r.SetPathParam({{ printf "%q" .Name }}, {{ if .Formatter }}{{ .Formatter }}({{ if .IsNullable }}*{{end}}{{ .ValueExpression }}){{ else }}{{ if .IsNullable }}*{{end}}{{ .ValueExpression }}{{ if .IsCustomFormatter }}.String(){{end}}{{end}}); err != nil {
    return err
  }
  {{ else if .IsHeaderParam }}
  // header param {{ .Name }}
  if err := r.SetHeaderParam({{ printf "%q" .Name }}, {{ if .Formatter }}{{ .Formatter }}({{ if .IsNullable }}*{{end}}{{ .ValueExpression }}){{ else }}{{ if .IsNullable }}*{{end}}{{ .ValueExpression }}{{ if .IsCustomFormatter }}.String(){{end}}{{end}}); err != nil {
    return err
  }
  {{ else if .IsFormParam }}
  {{ if .IsFileParam }}
  {{ if .IsNullable}}
  if {{ .ValueExpression }} != nil {
  {{end}}
    // form file param {{ .Name }}
    if err := r.SetFileParam({{ printf "%q" .Name }}, {{ if not .IsNullable}}&{{end}}{{ .ValueExpression }}); err != nil {
      return err
    }
  {{ if .IsNullable}}
  }
  {{ end }}
  {{ else }}
  // form param {{ .Name }}
  {{ if .IsNullable }}var fr{{ pascalize .Name }} {{ .GoType }}
  if {{ .ValueExpression }} != nil {
    fr{{ pascalize .Name }} = *{{ .ValueExpression }}
  }{{ else }}fr{{ pascalize .Name }} := {{ .ValueExpression }}{{ end}}
  f{{ pascalize .Name}} := {{ if .Formatter }}{{ .Formatter }}(fr{{ pascalize .Name }}){{ else }}fr{{ pascalize .Name }}{{ if .IsCustomFormatter }}.String(){{end}}{{end}}{{ if not .AllowEmptyValue }}
  if f{{ pascalize .Name }} != "" { {{ end }}
  if err := r.SetFormParam({{ printf "%q" .Name }}, f{{ pascalize .Name }}); err != nil {
    return err
  }
  {{ if not .AllowEmptyValue }}}{{ end }}
  {{ end }}
  {{ end }}
  {{ if and .IsNullable (not .AllowEmptyValue) }}}{{end}}
  {{else if .IsArray }}
  {{ if not .IsBodyParam }}{{ if .Child }}{{ if or .Child.Formatter .Child.IsCustomFormatter }}var values{{ pascalize .Name }} []string
  for _, v := range {{ if and (not .IsArray) (not .IsMap) (not .IsStream) (.IsNullable) }}*{{end}}{{ .ValueExpression }} {
    values{{ pascalize .Name }} = append(values{{ pascalize .Name }}, {{ .Child.Formatter }}{{ if .Child.Formatter }}({{ end }}v{{ if .Child.IsCustomFormatter }}.String(){{ end }}{{ if .Child.Formatter }}){{ end }})
  }
  {{ else }}values{{ pascalize .Name }} := {{ if and (not .IsArray) (not .IsStream) (not .IsMap) (.IsNullable) }}*{{end}}{{ .ValueExpression }}{{ end }}
  {{ else }}values{{ pascalize .Name }} := {{ if and (not .IsArray) (not .IsStream) (not .IsMap) (.IsNullable) }}*{{end}}{{ .ValueExpression }}{{ end }}
  joined{{ pascalize .Name}} := swag.JoinByFormat(values{{ pascalize .Name }}, "{{.CollectionFormat}}")
  {{ if .IsQueryParam }}// query array param {{ .Name }}
  if err := r.SetQueryParam({{ printf "%q" .Name }}, joined{{ pascalize .Name }}...); err != nil {
    return err
  }
  {{ else if and .IsFormParam }}// form array param {{ .Name }}
  if err := r.SetFormParam({{ printf "%q" .Name }}, joined{{ pascalize .Name }}...); err != nil {
    return err
  }
  {{ end }}{{ end }}

  {{ end }}

  {{if .IsBodyParam}}
  {{ if and .Schema.IsComplexObject .Schema.IsNullable (not .HasDiscriminator) }}if {{ .ValueExpression }} == nil {
    {{ .ValueExpression }} = {{ .ZeroValue }}
  }{{ end }}

  if err := r.SetBodyParam({{ .ValueExpression }}); err != nil {
    return err
  }
  {{end}}
  {{end}}
  if len(res) > 0 {
    return errors.CompositeValidationError(res...)
  }
  return nil
}
