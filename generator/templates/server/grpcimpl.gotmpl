package {{ .Package }}{{ $package := .Package }}

{{ $grpcPath := "../../grpc" }}
//go:generate protoc --go_out=plugins=grpc:{{ $grpcPath }} --proto_path={{ $grpcPath }} {{ $grpcPath }}/*.proto

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the generate command

import (
  "golang.org/x/net/context"
  "google.golang.org/grpc"

  {{ range .DefaultImports }}{{ printf "%q" . }}
  {{ end }}
  {{ range $key, $value := .Imports }}{{ $key }} {{ printf "%q" $value }}
  {{ end }}
)
{{ range .Models }}
func encode{{ pascalize .PbType }}(v *{{if ne .Package $package}}{{.Package}}.{{end}}{{ .GoType }}) *pb.{{ pascalize .PbType }} {
    return &pb.{{ pascalize .PbType }} {
{{ range $i, $param := .Properties }}    {{ camelize .Name | capitalize }}: {{ if and (not .IsMap) .IsNullable }}*{{ end }}v.{{ pascalize .Name }},
{{ end }}
    }
}
func decode{{ pascalize .PbType }}(v *pb.{{ pascalize .PbType }}) *{{if ne .Package $package}}{{.Package}}.{{end}}{{ .GoType }} {
    return &{{if ne .Package $package}}{{.Package}}.{{end}}{{ .GoType }} {
{{ range $i, $param := .Properties }}    {{ pascalize .Name }}: {{ if and (not .IsMap) .IsNullable }}&{{ end }}v.{{ camelize .Name | capitalize }},
{{ end }}
    }
}
{{ end }}
{{ $serviceName := pascalize .Name | printf "%sGrpcServiceServer" }}
type {{ $serviceName }} struct {
    *{{ pascalize .Name }}API
}
func New{{ $serviceName }}(api *{{ pascalize .Name }}API) *{{ $serviceName }} {
    return &{{ $serviceName }} { api }
}
{{ range .Operations }}
func ({{.ReceiverName}} *{{ $serviceName }}) {{ pascalize .Name }}(ctx context.Context, req *pb.{{ pascalize .Name }}Request) (*pb.{{ pascalize .Name }}Response, error) {
    params := {{if ne .Package $package}}{{.Package}}.{{end}}{{ pascalize .Name }}Params {
        {{ range .Params }}{{ pascalize .Name }}: {{ if .IsComplexObject }}decode{{ pascalize .PbType }}(req.{{ camelize .Name | capitalize }}){{ else }} req.{{ camelize .Name | capitalize }}{{ end }},
        {{ end }}
    }

    res := {{ .ReceiverName }}.{{ if ne .Package $package }}{{ pascalize .Package }}{{ end }}{{ pascalize .Name }}Handler.Handle(params, nil)
    {{ $responseName := pascalize .Name | printf "%sResponse" }}
    switch resp := res.(type) {
    {{ range .Responses }}case *{{ if ne .Package $package }}{{ .Package }}.{{ end }}{{ pascalize .Name }}:
        return &pb.{{ $responseName }} {
            &pb.{{ $responseName }}_{{ pascalize .Name  }} {
                &pb.{{ pascalize .Name  }}{
                    {{ with .Schema }}{{ if .IsComplexObject }}encode{{ pascalize .PbType }}(resp.Payload){{ else }}resp.Payload{{ end }},{{ end }}
                },
            },
        }, nil
    {{ end }}
    {{ with .DefaultResponse }}
    case *{{ if ne .Package $package }}{{ .Package }}.{{ end }}{{ pascalize .Name }}:
        return &pb.{{ $responseName }} {
            &pb.{{ $responseName }}_{{ pascalize .Name  }} {
                &pb.{{ pascalize .Name  }}{
                    {{ with .Schema }}{{ if .IsComplexObject }}encode{{ pascalize .PbType }}(resp.Payload){{ else }}resp.Payload{{ end }},{{ end }}
                },
            },
        }, nil
    default:
        return &pb.{{ $responseName }} { &pb.{{ $responseName }}_{{ pascalize .Name  }} { new(pb.{{ pascalize .Name }}) } }, nil
    {{ end }}}
}
{{ end }}
