{{define "slicevalidator"}}
{{if .NeedsSize}}
{{.ParamName}}Size := int64(len({{.ValueExpression}}))
{{end}}
{{if .MinItems}}
if err := validate.MinItems({{.Path}}, "{{.Location}}", {{.ParamName}}Size, {{.MinItems}}); err != nil {
  return err
}
{{end}}
{{if .MaxItems}}
if err := validate.MaxItems({{.Path}}, "{{.Location}}", {{.ParamName}}Size, {{.MaxItems}}); err != nil {
  return err
}
{{end}}
{{if .UniqueItems}}
if err := validate.UniqueItems({{.Path}}, "{{.Location}}", {{.ValueExpression}}); err != nil {
  return err
}
{{end}}
{{if .Enum}}
if err := validate.Enum({{.Path}}, "{{.Location}}", {{.ValueExpression}}, {{.Enum}}); err != nil {
  return err
}
{{end}}
{{end}}{{define "propertyvalidator"}}
{{if .IsPrimitive}}{{template "primitivevalidator" .}}{{end}}
{{if .IsCustomFormatter}}{{template "customformatvalidator" .}}{{end}}
{{if .IsContainer}}{{template "slicevalidator" .}}{{end}}
{{end}}{{define "bindprimitive"}}
{{end}}{{define "slicebinder"}}
{{if .Parent}}{{.IndexVar}}c := swag.SplitByFormat({{.Parent.IndexVar}}c[{{.Parent.IndexVar}}], "{{.CollectionFormat}}")
{{else}}{{.IndexVar}}c := raw{{end}}
{{.IndexVar}}sz := size
var {{.IndexVar}}r {{.Type}}
{{.IndexVar}}ValidateElement := func({{.IndexVar}} int, {{.Child.ValueExpression}} {{.Child.Type}}) *errors.Validation {
  {{template "propertyvalidator" .Child}}
  return nil
}

for {{.IndexVar}} := 0; {{.IndexVar}} < {{.IndexVar}}sz; {{.IndexVar}}++ {
  {{if or .Child.IsCustomFormatter .Child.IsPrimitive}}{{if .Child.Converter}}value, err := {{.Child.Converter}}({{.IndexVar}}c[{{.IndexVar}}])
  if err != nil {
    return errors.InvalidType({{.Child.Path}}, "{{.Location}}", "{{.Child.Type}}", {{.IndexVar}}c[{{.IndexVar}}])
  }

  if err := {{.IndexVar}}ValidateElement({{.IndexVar}}, {{.Child.ValueExpression}}); err != nil {
    return err
  }
  {{.IndexVar}}r = append({{.IndexVar}}r, value)
  {{else}}
    if err := {{.IndexVar}}ValidateElement({{.IndexVar}}, {{.IndexVar}}c[{{.IndexVar}}]); err != nil {
      return err
    }
  {{.IndexVar}}r = append({{.IndexVar}}r, {{.IndexVar}}c[{{.IndexVar}}]){{end}}{{else if .Child.IsContainer}}
  {{template "slicebinder" .Child}}
    if err := {{.IndexVar}}ValidateElement({{.IndexVar}}, {{.Child.IndexVar}}r); err != nil {
      return err
    }
  {{.IndexVar}}r = append({{.IndexVar}}r, {{.Child.IndexVar}}r){{end}}
}
{{end}}package {{.Package}}

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
  "net/http"
  "github.com/go-swagger/go-swagger/httpkit"
  "github.com/go-swagger/go-swagger/swag"
  "github.com/go-swagger/go-swagger/errors"
  "github.com/go-swagger/go-swagger/httpkit/validate"
  "github.com/go-swagger/go-swagger/httpkit"

  {{range .DefaultImports}}{{printf "%q" .}}
  {{end}}
  {{range $key, $value := .Imports}}{{$key}} {{ printf "%q" $value}}
  {{end}}
)

// {{.ClassName}}Params contains all the bound params for the {{.HumanClassName}} operation
// typically these are obtained from a http.Request
type {{.ClassName}}Params struct {
  {{range .Params}}{{if .Description}}// {{.Description}}{{end}}
  {{.PropertyName}} {{.Type}}
  {{end}}
}

// BindRequest both binds and validates a request, it assumes that complex things implement a Validatable(strfmt.Registry) error interface
// for simple values it will use straight method calls
func ({{.ReceiverName}} *{{.ClassName}}Params) BindRequest(r *http.Request, route *middleware.MatchedRoute) error {
  var res []error
  {{if .HasQueryParams}}qs := r.URL.Query()
  {{else if .HasFormParams}}
  {{end}}

  {{range .Params}}
  {{if not .IsContainer}}{{if .IsQueryParam}}if err := {{.ReceiverName}}.bind{{.PropertyName}}(qs.Get({{.Path}}), route.Formats); err != nil {
    res = append(res, err)
  }
  {{else if .IsPathParam}}if err := {{.ReceiverName}}.bind{{.PropertyName}}(route.Params.Get({{.Path}}), route.Formats); err != nil {
    res = append(res, err)
  }
  {{else if .IsHeaderParam}}if err := {{.ReceiverName}}.bind{{.PropertyName}}(r.Header.Get({{.Path}}), route.Formats); err != nil {
    res = append(res, err)
  }
  {{else if .IsFormParam}}{{if .IsFileParam}}{{.ParamName}}, {{.ParamName}}Header, err := r.FormFile({{.Path}})
  if err != nil {
    res = append(res, errors.New(400, "reading file \"{{.ParamName}}\" failed: %v", err))
  } else {
    {{.ReceiverName}}.{{.PropertyName}} = httpkit.File{Data: {{.ParamName}}, Header: {{.ParamName}}Header}
  }
  {{else}}if err := {{.ReceiverName}}.bind{{.PropertyName}}(r.FormValue({{.Path}}), route.Formats); err != nil {
    res = append(res, err)
  }
  {{end}}{{end}}
  {{else if .IsContainer}}{{if .IsQueryParam}}if err := {{.ReceiverName}}.bind{{.PropertyName}}(swag.SplitByFormat(qs.Get({{.Path}}), "{{.CollectionFormat}}"), route.Formats); err != nil {
    res = append(res, err)
  }
  {{else if and .IsFormParam}}if err := {{.ReceiverName}}.bind{{.PropertyName}}(swag.SplitByFormat(r.FormValue({{.Path}}), "{{.CollectionFormat}}"), route.Formats); err != nil {
    res = append(res, err)
  }
  {{end}}{{end}}

  {{if .IsBodyParam}}
  if err := route.Consumer.Consume(r.Body, &{{.ReceiverName}}.{{.PropertyName}}); err != nil {
    res = append(res, errors.NewParseError("{{.ParamName}}", "{{.Location}}", "", err))
  } else {
    {{if .IsContainer}}for _, {{.IndexVar}}{{.ReceiverName}} := range {{.ReceiverName}}.{{.PropertyName}} {
      if err := {{.IndexVar}}{{.ReceiverName}}.Validate(route.Formats); err != nil {
        res = append(res, err)
        break
      }
    }
    {{else}}if err := {{.ReceiverName}}.{{.PropertyName}}.Validate(route.Formats); err != nil {
      res = append(res, err)
    }
    {{end}}
  }

  {{end}}
  {{end}}
  if len(res) > 0 {
    return errors.CompositeValidationError(res...)
  }
  return nil
}

{{ $className := .ClassName }}
{{range .Params}}
{{if not .IsBodyParam}}
{{if or .IsPrimitive .IsCustomFormatter}}
func ({{.ReceiverName}} *{{$className}}Params) bind{{.PropertyName}}(raw string, formats strfmt.Registry) error {
  {{if and (not .IsPathParam) .Required}}if err := validate.RequiredString({{.Path}}, "{{.Location}}", raw); err != nil {
    return err
  }
  {{end}}
  {{if .Converter}}value, err := {{.Converter}}(raw)
  if err != nil {
    return errors.InvalidType({{.Path}}, "{{.Location}}", "{{.Type}}", raw)
  }
  {{.ValueExpression}} = value
  {{else}}{{.ValueExpression}} = raw
  {{end}}
  {{if .HasValidations}}if err := {{.ReceiverName}}.validate{{.PropertyName}}(formats); err != nil {
    return err
  }
  {{end}}
  return nil
}
{{else if .IsContainer}}
func ({{.ReceiverName}} *{{$className}}Params) bind{{.PropertyName}}(raw []string, formats strfmt.Registry) error {
  size := len(raw)

  {{if .Required}}if size == 0 {
    return errors.Required({{.Path}}, "{{.Location}}")
  }
  {{end}}

  {{if .DefaultValue}}defValue := swag.SplitByFormat({{.DefaultValue}}, "{{.CollectionFormat}}")
  if size == 0 && len(defValue) > 0 {
    {{.ValueExpression}} = defValue
  {{else}}if size == 0 {
    return nil{{end}}
  }
  {{template "slicebinder" .}}
  {{.ValueExpression}} = {{.IndexVar}}r
  {{if .HasSliceValidations}}if err := {{.ReceiverName}}.validate{{.PropertyName}}(formats); err != nil {
    return err
  }
  {{end}}

  return nil
}
{{end}}
{{if or .HasValidations .HasSliceValidations}}
func ({{.ReceiverName}} *{{$className}}Params) validate{{.PropertyName}}(formats strfmt.Registry) error {
  {{template "propertyvalidator" .}}
  return nil
}
{{end}}
{{end}}
{{end}}
